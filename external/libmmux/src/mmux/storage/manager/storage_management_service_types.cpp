/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "storage_management_service_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace mmux { namespace storage {

int _krpc_block_stateValues[] = {
  rpc_regular,
  rpc_importing,
  rpc_exporting
};
const char* _krpc_block_stateNames[] = {
  "rpc_regular",
  "rpc_importing",
  "rpc_exporting"
};
const std::map<int, const char*> _rpc_block_state_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _krpc_block_stateValues, _krpc_block_stateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const rpc_block_state val) {
  std::map<int, const char*>::const_iterator it = _rpc_block_state_VALUES_TO_NAMES.find(val);
  if (it != _rpc_block_state_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}


storage_management_exception::~storage_management_exception() throw() {
}


void storage_management_exception::__set_msg(const std::string& val) {
  this->msg = val;
}
std::ostream& operator<<(std::ostream& out, const storage_management_exception& obj)
{
  obj.printTo(out);
  return out;
}


void swap(storage_management_exception &a, storage_management_exception &b) {
  using ::std::swap;
  swap(a.msg, b.msg);
  swap(a.__isset, b.__isset);
}

storage_management_exception::storage_management_exception(const storage_management_exception& other0) : TException() {
  msg = other0.msg;
  __isset = other0.__isset;
}
storage_management_exception& storage_management_exception::operator=(const storage_management_exception& other1) {
  msg = other1.msg;
  __isset = other1.__isset;
  return *this;
}
void storage_management_exception::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "storage_management_exception(";
  out << "msg=" << to_string(msg);
  out << ")";
}

const char* storage_management_exception::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: storage_management_exception";
  }
}


rpc_slot_range::~rpc_slot_range() throw() {
}


void rpc_slot_range::__set_slot_begin(const int32_t val) {
  this->slot_begin = val;
}

void rpc_slot_range::__set_slot_end(const int32_t val) {
  this->slot_end = val;
}
std::ostream& operator<<(std::ostream& out, const rpc_slot_range& obj)
{
  obj.printTo(out);
  return out;
}


void swap(rpc_slot_range &a, rpc_slot_range &b) {
  using ::std::swap;
  swap(a.slot_begin, b.slot_begin);
  swap(a.slot_end, b.slot_end);
}

rpc_slot_range::rpc_slot_range(const rpc_slot_range& other2) {
  slot_begin = other2.slot_begin;
  slot_end = other2.slot_end;
}
rpc_slot_range& rpc_slot_range::operator=(const rpc_slot_range& other3) {
  slot_begin = other3.slot_begin;
  slot_end = other3.slot_end;
  return *this;
}
void rpc_slot_range::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "rpc_slot_range(";
  out << "slot_begin=" << to_string(slot_begin);
  out << ", " << "slot_end=" << to_string(slot_end);
  out << ")";
}

}} // namespace
